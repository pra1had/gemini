import json
from typing import List, Dict, Any
from backend.models import Scenario, ScenarioStep, StepRowData
# import mistune # Import when implementing parsing

# --- Constants for Markdown Formatting ---
# These might need adjustment based on the exact Concordion dialect/setup
COMMAND_NAMESPACE = "c" # Example Concordion command namespace

def _format_step_data_for_markdown(step_data: List[StepRowData]) -> str:
    """
    Formats the step_data (list of dictionaries) into a Markdown representation.
    For now, using a simple JSON representation within a code block.
    Could be adapted to use nested Markdown tables if required by Concordion setup.
    """
    if not step_data:
        return ""
    # Simple JSON representation
    try:
        # Pretty print JSON for readability in Markdown
        json_string = json.dumps(step_data, indent=2)
        return f"```json\n{json_string}\n```"
    except TypeError:
        # Fallback for non-serializable data, though Pydantic should handle most cases
        return f"```\n{step_data}\n```"

def generate_markdown(scenario: Scenario) -> str:
    """
    Generates a Concordion-compatible Markdown string from a Scenario object.
    Note: The exact Concordion command syntax (`c:set`, `c:execute`, etc.) and
    table structure might need refinement based on the specific test fixture setup.
    This implementation provides a basic structure.
    """
    lines = []

    # 1. Metadata (using comments or front matter - comments for simplicity now)
    lines.append(f"<!-- Scenario Name: {scenario.scenario_name} -->")
    if scenario.component_name:
        lines.append(f"<!-- Component: {scenario.component_name} -->")
    if scenario.tags:
        lines.append(f"<!-- Tags: {', '.join(scenario.tags)} -->")
    lines.append("") # Blank line after metadata

    # 2. Scenario Title
    lines.append(f"# Scenario: {scenario.scenario_name}")
    lines.append("")

    # 3. Flow Steps (using a table structure)
    if not scenario.flow_steps:
        lines.append("*(No steps defined)*")
        return "\n".join(lines)

    # Determine headers - Use action_code and a generic 'Data/Parameters' column
    # More complex logic might be needed if data needs specific columns based on action type
    lines.append("| Step | Action | Data / Parameters |")
    lines.append("|------|--------|-------------------|")

    for i, step in enumerate(scenario.flow_steps):
        # Format action code - potentially map to Concordion command?
        # Example: Using action_code directly, assuming fixture interprets it.
        # A more complex mapping might use step.action_code to determine c:execute vs c:set etc.
        action_command = f"`{step.action_code}`" # Simple representation for now

        # Format step data
        data_representation = _format_step_data_for_markdown(step.step_data)
        # Ensure multi-line data is handled correctly within the table cell
        data_representation = data_representation.replace("\n", "<br/>") # Use <br/> for newlines in Markdown table

        lines.append(f"| {i+1} | {action_command} | {data_representation} |")

    lines.append("") # Blank line after table
    return "\n".join(lines)


def parse_markdown(markdown_content: str) -> Scenario:
    """
    Parses a Concordion-compatible Markdown string back into a Scenario object.
    Placeholder implementation. Requires robust parsing based on the
    specific Markdown structure generated by generate_markdown and expected
    by Concordion. Libraries like mistune or custom regex might be needed.
    """
    # TODO: Implement robust Markdown parsing logic
    # - Extract metadata (Name, Component, Tags) from comments/front matter
    # - Parse the table structure to get steps (action_code)
    # - Extract and parse the data representation (e.g., JSON in code blocks) back into step_data
    print("[Warning] parse_markdown is a placeholder and does not fully parse content.")

    # Basic placeholder extraction (highly simplified)
    scenario_name = "Parsed Scenario (Placeholder)"
    component_name = None
    tags = []
    flow_steps = []

    # Attempt to find metadata (very basic)
    import re
    name_match = re.search(r"<!-- Scenario Name: (.*) -->", markdown_content)
    if name_match:
        scenario_name = name_match.group(1).strip()
    comp_match = re.search(r"<!-- Component: (.*) -->", markdown_content)
    if comp_match:
        component_name = comp_match.group(1).strip()
    tags_match = re.search(r"<!-- Tags: (.*) -->", markdown_content)
    if tags_match:
        tags = [tag.strip() for tag in tags_match.group(1).split(',')]

    # Placeholder steps (does not parse table)
    # A real implementation would need to parse the Markdown table rows
    # and the JSON data within cells.

    return Scenario(
        scenario_name=scenario_name,
        component_name=component_name,
        tags=tags,
        flow_steps=flow_steps # Return empty steps for now
    )
