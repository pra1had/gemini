# Product Context

## Why This Project Exists

This project provides a backend utility service designed to support a separate frontend system.

## What Problems It Solves

The primary goal is to simplify the process for the frontend system to construct complex API request Data Transfer Objects (DTOs). It achieves this by providing a structured, tabular description of various target APIs based on their OpenAPI specifications. The frontend can use this structured information to dynamically build user interfaces or forms for creating API requests.

## How It Should Work

1.  **Manifest Fetching:** The service fetches a central manifest JSON from a configured HTTP endpoint. This manifest lists different components and the URLs for the OpenAPI schema associated with each "action code" (API endpoint).
2.  **OpenAPI Fetching & Parsing:** For each action code listed in the fetched manifest, the service fetches the corresponding OpenAPI specification from its specified URL using a REST client. It then uses the `swagger-parser` library to parse the fetched schema content. The parser handles `$ref` resolution (potentially including remote references if configured).
3.  **`/action-codes` Endpoint:** The service exposes a single GET endpoint: `/action-codes`.
4.  **Structured JSON Response:** When called, the `/action-codes` endpoint returns a JSON array. Each object in the array represents an "action code" and contains structured information extracted and mapped from the OpenAPI specification and the manifest file. This includes:
    *   `componentName`: The logical grouping of the API.
    *   `actionCode`: The specific API operation identifier.
    *   `actionCodeGroupName`: A category tag for the action.
    *   `endPoint`: The relative URL path of the target API.
    *   `type`: The nature of the operation ("PostAndVerify" for POST, "FetchAndVerify" for GET).
    *   `pathPropertyListMap`: Lists of required path and query parameters, including their names, mandatory status, and descriptions (used as `derivedDataType`).
    *   `RequestBodyColumnList`: A flattened list of all potential fields within the request body schema. Each item includes the technical name, mandatory status, and a derived data type path indicating its position in the original nested structure (e.g., `:props:effectiveFrom`). This flattening handles nested objects and arrays.
5.  **Assumptions:**
    *   Each OpenAPI file defines exactly one path.
    *   The `actionCodeGroupName` is taken from the first tag in the operation's `tags` array.
    *   The service relies on `swagger-parser` to handle `$ref` pointers within the fetched schemas.

---

## Frontend Application (`src/`) - Scenario Workbench UI

### Why This Project Exists

This frontend application provides the user interface for the "Scenario Workbench". It serves Product Owners (POs) and Quality Assurance (QA) teams who need a structured way to define and manage business and test scenarios involving sequences of backend API calls. It aims to replace unstructured methods like manual Excel editing.

### What Problems It Solves

*   **Lack of Structure:** Provides a dedicated, structured UI for defining complex API scenarios, which is difficult in spreadsheets or text documents.
*   **Collaboration:** Facilitates collaboration between POs and QAs in defining scenarios.
*   **Integration:** Integrates scenario definition directly with development and testing workflows through Git and Concordion-compatible output (generated by the backend).
*   **Usability:** Offers a user-friendly, Excel-like interface for data entry, catering to the preferences of PO and QA users.

### How It Should Work

1.  **Scenario Management:** Users can search for existing scenarios (stored as Markdown in Git, accessed via the backend), create new scenarios, edit existing ones, and duplicate scenarios.
2.  **Action Discovery:** The UI fetches a list of available "Actions" (representing backend API calls) from the backend/middleware service (`/api/actions`).
3.  **Scenario Building:**
    *   Users select Actions from the list and add them as steps to a "Your Flow" panel.
    *   Steps in the flow can be reordered (drag-and-drop) and removed.
4.  **Data Entry:**
    *   Each step in the flow can be expanded inline.
    *   Based on the Action type, relevant data entry sections (Parameters, Request Body, Verification) are displayed.
    *   An "Excel-like" grid component is used for tabular data entry, supporting features like copy/paste, keyboard navigation, and add/remove rows.
    *   Data entered is held in the UI state. (US-005 Revised indicates implicit save within the step/UI state before final review/save).
5.  **Review & Save:**
    *   Before saving, users navigate to a "Review" view showing a read-only summary of the scenario (metadata, target repo, steps, data).
    *   Clicking "Save" on the Review view triggers a backend API call (`/api/scenarios/save`).
    *   The backend handles generating the Concordion-compatible Markdown and committing it to a specified GitHub repository via a new branch and Pull Request.
    *   The UI displays the success status and a link to the created PR.
6.  **Export:** Users can export the current scenario to a standard (non-annotated) Excel file via a backend endpoint (`/api/scenarios/export/excel`).
7.  **Role-Based Access:** UI features (Create, Edit, Save, Duplicate, Export) are enabled/disabled based on the user's role (PO, QA, Developer), determined via backend configuration/authentication.
